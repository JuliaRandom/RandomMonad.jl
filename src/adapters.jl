## Const

struct Const{T} <: Distribution{T}
    x::T
end

rand(::AbstractRNG, sp::SamplerTrivial{<:Const}) = sp[].x


## algebra

struct Op2{T,F,A,B} <: Distribution{T}
    f::F
    a::A
    b::B

    Op2{T}(f::F, a::A, b::B) where {T,F,A,B} = new{T,F,A,B}(f, a, b)
end

Op2(f::F, a::A, b::B) where {F,A,B} =
    Op2{typeof(f(one(gentype(a)), one(gentype(b))))}(f, a, b)

Sampler(RNG::Type{<:AbstractRNG}, x::Op2, n::Repetition) =
    SamplerTag{typeof(x)}((f = x.f,
                           a = Sampler(RNG, x.a, n),
                           b = Sampler(RNG, x.b, n)))

function reset!(sp::SamplerTag{<:Op2}, n...)
    reset!(sp.data.a, n...)
    reset!(sp.data.b, n...)
    sp
end

rand(rng::AbstractRNG, sp::SamplerTag{<:Op2{T}}) where {T} =
    sp.data.f(rand(rng, sp.data.a), rand(rng, sp.data.b))::T


### instances

for op = (:+, :-, :*, :/, :^)
    @eval begin
        (Base.$op)(a::Distribution, b::Distribution) = Op2($op, a,        b)
        (Base.$op)(a,               b::Distribution) = Op2($op, Const(a), b)
        (Base.$op)(a::Distribution, b              ) = Op2($op, a,        Const(b))
    end
end


### getindex

Op2(::typeof(getindex), a::A, b::B) where {A,B} =
    Op2{eltype(gentype(a))}(getindex, a, b)

"""
    getindex(X::Distribution, Y::Distribution) :: Distribution

Return a distribution yielding `x[y]` where `x <- X` and `y <- Y`.

# Examples
```julia
julia> rand(Const('a':'z')[Uniform(1:3)])
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
```
"""
Base.getindex(a::Distribution, b::Distribution) = Op2(getindex, a, b)


## Bind

"""
    Bind(f, X)

Generate a random value `x` from distribution `X`, and then
generate a random value from distribution specified by `f(x)`.

!!! note
    This is roughly equivalent to the `>>=` bind monadic operator
    in Haskell, but with the order of arguments reversed.

# Examples

The following expression generates 4 arrays of `Bool` (`Fill(Bool, n)`),
whose length `n` is chosen at random in `1:5`:
```julia
julia> rand(Bind(n -> Fill(Bool, n), 1:5), 4)
4-element Array{Array{Bool,1},1}:
 [1, 0, 1]
 [1, 1]
 [1, 0, 0, 1, 0]
 [1]
```
If multiple values must be passed to the function, `Zip` can be used
to combine distributions. For example, the following `Bind` construction
generates arrays of length yielded by `Shuffle(1:4)` (i.e. each array has
a distinct length in `1:4`), and whose elements are generated by a
distribution selected randomly in `[Bool, Normal(), 1:9]`:
```julia
julia> b = Bind(Zip([Bool, Normal(), 1:9], Shuffle(1:4))) do (t, n)
               Fill(t, n)
           end;

julia> rand(b, 4)
4-element Array{Any,1}:
 [-0.2900266833838387]
 Bool[0, 0, 1]
 Bool[0, 1, 1, 0]
 [6, 1]
```

!!! note
    The distribution specified by `f(x)` is not known until
    `rand` is called, which means that the "staged" approach
    enabled by the `Sampler` machinery cannot be fully
    exploited. So while `Bind` is a powerful general tool,
    specialized implementations of certain constructions might
    achieve better performance.
"""
struct Bind{F,X,T} <: Distribution{T}
    f::F
    x::X

    Bind{T}(f::F, x::X) where {T,F,X} = new{F,X,T}(f, x)
end

function Bind(f::F, x::X) where {X,F}
    rt = Base.return_types(f, (gentype(x),))
    T = length(rt) > 1 ? Any : rt[1]
    Bind{gentype(T)}(f, x)
end

Sampler(::Type{RNG}, b::Bind, n::Repetition) where {RNG<:AbstractRNG} =
    SamplerTag{typeof(b)}((x = Sampler(RNG, b.x, n),
                           f = b.f))

function rand(rng::AbstractRNG, sp::SamplerTag{<:Bind})
    x = rand(rng, sp.data.x)
    rand(rng, sp.data.f(x))
end


## Filter

struct Filter{T,F,D<:Distribution{T}} <: Distribution{T}
    f::F
    d::D
end

Filter(f::F, d) where {F} = Filter(f, Uniform(d))


### sampling

Sampler(RNG::Type{<:AbstractRNG}, d::Filter, n::Repetition) =
    SamplerTag{typeof(d)}((f = d.f,
                           d = Sampler(RNG, d.d, n)))

reset!(sp::SamplerTag{<:Filter}, n=0) = (reset!(sp.data.d, n); sp)

rand(rng::AbstractRNG, sp::SamplerTag{<:Filter}) =
    while true
        x = rand(rng, sp.data.d)
        sp.data.f(x) && return x
    end


## Lift

struct Lift{T,F,D} <: Distribution{T}
    f::F
    d::D
end

Lift{T}(f::F, d...) where {T,F} = Lift{T,F,typeof(d)}(f, d)

function Lift(f::F, d...) where {F}
    rt = Base.return_types(f, map(gentype, d))
    T = length(rt) > 1 ? Any : rt[1]
    Lift{T}(f, d...)
end


### sampling

# Repetition -> Val(1)
rand(rng::AbstractRNG, sp::SamplerTrivial{<:Lift{T}}) where {T} =
    convert(T, sp[].f((rand(rng, d) for d in sp[].d)...))

Sampler(RNG::Type{<:AbstractRNG}, m::Lift, n::Val{Inf}) =
    SamplerTag{typeof(m)}((f = m.f,
                           d = map(x -> Sampler(RNG, x, n), m.d)))

reset!(sp::SamplerTag{<:Lift}, n=0) =
    (foreach(s -> reset!(s, n), sp.data.d); sp)

rand(rng::AbstractRNG, sp::SamplerTag{<:Lift{T}}) where {T} =
    convert(T, sp.data.f((rand(rng, d) for d in sp.data.d)...))


## Reduce

struct Reduce{T,F,D} <: Distribution{T}
    f::F
    d::D
end

Reduce{T}(f::F, d) where {T,F} = Reduce{T,F,typeof(d)}(f, d)

# we only support reduce for f(::X, ::X) -> X
# use Lift + Base.reduce for more complicated cases
Reduce(f::F, d) where {F} = Reduce{eltype(gentype(d))}(f, d)


### sampling

rand(rng::AbstractRNG, sp::SamplerTrivial{<:Reduce{T}}) where {T} =
    convert(T, reduce(sp[].f, rand(rng, sp[].d)))

Sampler(RNG::Type{<:AbstractRNG}, r::Reduce, n::Val{Inf}) =
    SamplerTag{typeof(r)}((f = r.f,
                           d = Sampler(RNG, r.d, n)))

reset!(sp::SamplerTag{<:Reduce}, n=0) = (reset!(sp.data.d, n); sp)

rand(rng::AbstractRNG, sp::SamplerTag{<:Reduce{T}}) where {T} =
    convert(T, reduce(sp.data.f, rand(rng, sp.data.d)))


## Counts

"""
    Counts(x) :: Distribution{<:Dict}

Create a distribution yielding a dictionary whose keys are the elements
of the collection yielded by distribution `x`, and whose values are the
number of times each element appeared in the collection.

# Examples
```julia
julia> rand(Counts(Fill(Categorical([1/6, 2/6, 3/6]), 600)))
Dict{Int64,Int64} with 3 entries:
  2 => 193
  3 => 306
  1 => 101
```
"""
struct Counts{T,X} <: Distribution{Dict{T,Int}}
    x::X

    Counts(x::X) where {X} = new{eltype(gentype(x)),X}(x)
end

Sampler(::Type{RNG}, c::Counts, n::Repetition) where {RNG<:AbstractRNG} =
    SamplerTag{typeof(c)}(Sampler(RNG, c.x, n))

reset!(sp::SamplerTag{<:Counts}, n...) = (reset!(sp.data, n...); sp)

function rand(rng::AbstractRNG, sp::SamplerTag{<:Counts{T}}) where T
    dict = Dict{T,Int}()
    for x in rand(rng, sp.data)
        dict[x] = get(dict, x, 0) + 1
    end
    dict
end

"""
    counts(x, [n::Integer])

Equivalent to `rand(Counts(x))`, or to `rand(Counts(Fill(x, n)))`
when `n` is specified.

!!! warning
    Experimental function.
"""
counts(x) = rand(Counts(x))
counts(x, n) = rand(Counts(Fill(x, n)))


## Unique

struct Unique{T,X} <: Distribution{T}
    x::X

    Unique(x::X) where {X} = new{gentype(x),X}(x)
end

Unique(::Type{X}) where {X} = Unique(Uniform(X))

Sampler(RNG::Type{<:AbstractRNG}, u::Unique, n::Val{1}) =
    Sampler(RNG, u.x, n)

Sampler(RNG::Type{<:AbstractRNG}, u::Unique, n::Val{Inf}) =
    SamplerTag{typeof(u)}((x    = Sampler(RNG, u.x, n),
                           seen = Set{gentype(u)}()))

function reset!(sp::SamplerTag{<:Unique}, n=0)
    seen = sp.data.seen
    n > length(seen) && sizehint!(seen, n)
    empty!(seen)
    sp
end

function rand(rng::AbstractRNG, sp::SamplerTag{<:Unique})
    seen = sp.data.seen
    while true
        x = rand(rng, sp.data.x)
        x in seen && continue
        push!(seen, x)
        return x
    end
end


## Shuffling

### Fisher-Yates

struct FisherYates{T,A} <: Distribution{T}
    a::A

    FisherYates(a::AbstractArray{T}) where {T} =
        new{T,typeof(a)}(a)
end

struct SamplerFisherYates{T,A} <: Sampler{T}
    a::A
    inds::Vector{Int}
end

fy_inds(a) = Vector{Int}(undef, length(a) + 1)

Sampler(::Type{RNG}, fy::FisherYates{T,A}, ::Repetition) where {RNG<:AbstractRNG} where {T,A} =
    reset!(SamplerFisherYates{T,A}(fy.a, fy_inds(fy.a)))

fy_reset!(inds, n) = @inbounds inds[end] = -n # < 0 means not yet initialized

reset!(sp::SamplerFisherYates, n=length(sp.a)) = (fy_reset!(sp.inds, n); sp)

@noinline function fy_initialize!(rng, inds, k)
    k == 0 &&
        throw(ArgumentError("FisherYates: all elements have been consumed"))
    n = length(inds) - 1
    kn = n
    copyto!(inds, 1:n)
    m = n + k
    mask = nextpow(2, n) - 1
    while n != m
        (mask >> 1) == n && (mask >>= 1)
        i = 1 + rand(rng, Random.ltm52(n, mask))
        #^^^ faster equivalent to i = rand(rng, 1:n) (cf. Base.shuffle!)
        @inbounds inds[i], inds[n] = inds[n], inds[i]
        n -= 1
    end
    kn
end

function fy_rand(rng::AbstractRNG, inds, a)
    @inbounds begin
        k = inds[end] # contains the index in inds where the index in a is located
        if k <= 0
            k = fy_initialize!(rng, inds, k)
        end
        inds[end] = k - 1
        a[inds[k]]
    end
end

rand(rng::AbstractRNG, sp::SamplerFisherYates) = fy_rand(rng, sp.inds, sp.a)


### SelfAvoid

# cf. `self_avoid_sample!` in StatsBase.jl

struct SelfAvoid{T,A} <: Distribution{T}
    a::A

    SelfAvoid(a::AbstractArray{T}) where {T} =
        new{T,typeof(a)}(a)
end

struct SamplerSelfAvoid{T,A,S} <: Sampler{T}
    a::A
    seen::Set{Int}
    idx::S
end

sa_idx(::Type{RNG}, a) where {RNG} = Sampler(RNG, Base.OneTo(length(a)), Val(Inf))

function Sampler(RNG::Type{<:AbstractRNG}, sa::SelfAvoid{T,A}, ::Repetition) where {T,A}
    idx  = sa_idx(RNG, sa.a)
    SamplerSelfAvoid{T,A,typeof(idx)}(sa.a, Set{Int}(), idx)
end

sa_reset!(sp) = empty!(sp.seen)

reset!(sp::SamplerSelfAvoid, _=0) = (sa_reset!(sp); sp)

function sa_rand(rng::AbstractRNG, sp::Sampler{T})::T where T
    seen = sp.seen
    idx = sp.idx
    while true
        i = rand(rng, idx)
        if !(i in seen)
            push!(seen, i)
            return @inbounds sp.a[i]
        end
    end
end

rand(rng::AbstractRNG, sp::SamplerSelfAvoid) = sa_rand(rng, sp)


## Shuffle

struct Shuffle{T,A} <: Distribution{T}
    a::A

    Shuffle(a::AbstractArray{T}) where {T} = new{T,typeof(a)}(a)
end

mutable struct SamplerShuffle{T,A,S<:Sampler} <: Sampler{T}
    a::A
    alg::Int
    idx::S
    seen::Set{Int}
    inds::Vector{Int}

    SamplerShuffle(a::AbstractArray{T}, idx::S) where {T,S} =
        new{T,typeof(a),S}(a, 0, idx)
end

Sampler(::Type{RNG}, sh::Shuffle, n::Repetition) where {RNG<:AbstractRNG} =
    SamplerShuffle(sh.a, sa_idx(RNG, sh.a))

function reset!(sp::SamplerShuffle, n=-1)
    na = length(sp.a)
    if n < 0
        n = na
    end
    if n < 3
        sp.alg = typemin(Int)
    elseif na < n * 24 # TODO: do benchmarks
        if !isdefined(sp, :inds)
            sp.inds = fy_inds(sp.a)
        end
        fy_reset!(sp.inds, n)
        sp.alg = 3
    else
        if !isdefined(sp, :seen)
            sp.seen = Set{Int}()
        end
        sa_reset!(sp)
        sp.alg = 4
    end
    sp
end

function rand(rng::AbstractRNG, sp::SamplerShuffle)
    alg = sp.alg
    if alg < 0
        local i
        while true
            i = rand(rng, sp.idx)
            -i != alg && break
        end
        sp.alg = -i
        return @inbounds sp.a[i]
    elseif alg == 3
        fy_rand(rng, sp.inds, sp.a)
    elseif alg == 4
        sa_rand(rng, sp)
    else
        rand(rng, reset!(sp))
    end
end
